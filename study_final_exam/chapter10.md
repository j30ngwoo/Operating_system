## virtual memory

### 요구 페이징
1. 프로세스 내부 테이블을 검사, 메모리 참조가 유효/무효인지 탐지
2. 무효한 페이지에 대한 참조라면, 프로세스 중지
3. 가용 프레임 탐색
4. 보조저장장치에서 페이지 읽어들임
5. 페이지 테이블 수정 (invaild -> vaild)
6. 프로세스 다시 실행

### 가용 프레임 리스트

### 실질 접근 시간 = (1 - p) x memoryAccess + p x 페이지 폴트 시간

### copy on write

- fork()하였을 때 페이지가 수정되기 전까지는 부모의 페이지 같이 사용

### 페이지 교체
1. 보조저장장치에서 필요한 페이지의 위치 확인
2. 빈 페이지 프레임 찾기
	a. 비어 있는 프레임이 있다면 사용
	b. 비어 있는 프레임이 없다면 victim 프레임 선정을 위해 페이지 교체 알고리즘 가동
	c. victim 페이지를 보조저장장치에 기록(만약 수정되지 않았다면, 삭제), 테이블 수정
3. 빼앗은 프레임에 새 페이지를 읽어오고 테이블 수정
4. 페이지 폴트가 발생한 지점부터 프로세스 계속

- 페이지 폴트 횟수와 프레임 개수는 반비례

### 페이지 교체 알고리즘 444p
1. FIFO - 먼저 들어온 페이지부터 교체 
- Belady의 모순: 프레임이 늘었는데 페이지 폴트율이 더 증가
  
2. 최적 페이지 교체: 앞으로 가장 오랫동안 사용되지 않을 페이지를 찾아 교체
- 구현 어려움
  
3. LRU (least-recently-used) - 가장 오래 사용되지 않은 페이지부터 교체
- 스택으로 구현

4. LRU 근사 - 참조 비트로 구현
	a. 부가적 참조 비트 알고리즘
	b. 2차 기회 알고리즘

### 프레임 할당
1. 균등 할당
2. 비례 할당

### 전역/지역 할당
- 전역 할당: 교체할 프레임을 모든 프로세스의 프레임에서 탐색
- 지역 할당: 교체할 프레임을 해당 프로세스의 프레임에서만 탐색
  
### 페이지 회수 (전역 할당에서)
리퍼 루틴. 가용 메모리가 최소 임계값 이하가 되면 페이지 회수 시작 ~ 최대 임계값에서 종료

### 스레싱
지역 교체 알고리즘으로 제한

### 커널 메모리 할당
- 버디 할당
- 슬랩 할당
  
### Other Considerations
1. Prepaging 
2. Page size
- 커지면: 페이지 테이블 절약, 페이지당 I/O시간 감소
- 작아지면: internal fragmentaion 최소화, 총 I/O시간 감소, 정밀도 증가, 페이지 폴트 증가
3. TLB reach
4. Inverted page table
5. Program structure
6. I/O interlock and page locking